from normalisation import *
from bdd import *

def find_key(table, functional_dependencies, attributes):
    isolated_attributes = not_involved(table,functional_dependencies,attributes)
    rest = []
    for i in complementary(find_consequence(isolated_attributes, functional_dependencies), attributes):
        rest.append([i])
    if len(rest)-len(isolated_attributes) == 0:
        return [isolated_attributes]
    else:
        key = []
        prohibited_list = isolated_attributes[:]
        found = True
        iterations = 0
        while found or iterations < 2:
            iterations += 1
            #print "prohibited list : ",
            #print prohibited_list
            #print "rest : ",
            #print rest
            found = False
            for attribute_list in rest:
                boolean = True
                for i in attribute_list:
                    if i in prohibited_list:
                        #print i + " is in prohibited list, so rest = ",
                        boolean = False
                        rest.remove(attribute_list)
                        #print rest
                        break
                if boolean:
                    x = isolated_attributes[:]
                    for i in attribute_list:
                        x.append(i)
                    if included_in(attributes, find_consequence(x, functional_dependencies)+x):
                        found = True
                        iterations = 0
                        #print "key found :",
                        #print x,
                        #print " -> ",
                        #print find_consequence(x, functional_dependencies)
                        key.append(x)
                        prohibited_list = union(prohibited_list,x)
            if not found:
                rest = part(rest)
                #print "nothing found... new rest : ",
                #print rest
        return key

def comb(list, order):
    if len(list) < order :
        return []
    elif order == 1:
        new_list = []
        for elt in list:
            new_list.append([elt])
        return new_list
    else:
        new_list = []
        for i in range(1,order):
            for j in range(len(list)):
                if j < len(list):
                    sub_list = list[:j]+list[j+1:]
                else:
                    sub_list = list[:j]
                for elt in comb(sub_list, i):
                    new_list.append([list[j]]+elt)
        return new_list

def part(list):
    over_list = comb(list, len(list))
    sub_list = []
    for i in over_list :
        boolean = True
        for j in sub_list :
            if equals(i,j):
                boolean = False
                break
        if boolean :
            sub_list.append(i)
    return comb(list,1) + sub_list